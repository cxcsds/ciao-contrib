#!/usr/bin/env python

#
# Copyright (C) 2012, 2013, 2014, 2015, 2016, 2020, 2021, 2022
# Smithsonian Astrophysical Observatory
#
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
# 02110-1301 USA.
#

"""Usage:

  convert_xspec_user_model <name> <model.dat>

    --help
    --clobber  or -c
    --verbose n  or -v n where n is 0, 1, 2, 3, 4, 5
    --local
    --prefix [p]  where p is the prefix for the user model names
    --version
    --copyright

The script should be run in the directory containing the source code;
it follows the XSPEC initpackage command and will compile files that
match

  Fortran: *.f *.f03 *.f90
  C:       *.c
  C++:     *.cxx *.C *.cc *.cpp

Unlike most CIAO tools and scripts this does not use the CIAO
parameter interface, instead it uses the standard UNIX command-line
paradigm.  Use --help for more information.

Requires:

  XSPEC 12.12.0 or later (so we can use the include files from the
  install directory - in earlier versions the install location was
  not usable as the diectory structure had been flattened).

Aim:

Convert an XSPEC user model (written in Fortran, C, or C++) into a
Python module that can be used by Sherpa.

It is based in part on information from the create_xspec_extension
script (provided as part of the Sherpa source distribution) and the
initpackage command from the XSPEC source distribution.

See
http://heasarc.gsfc.nasa.gov/xanadu/xspec/manual/XSappendixLocal.html
for a description of the model.dat format.

"""

toolname = "convert_xspec_user_model"
toolver  = "03 November 2022"

import sys
import os
import string
import subprocess as sbp
import time
import glob
import argparse
import importlib
import shutil
from pathlib import Path
import sysconfig

import sherpa
import sherpa.astro.ui as ui
from sherpa.astro.utils import xspec
from sherpa.astro.xspec import get_xsversion

import ciao_version

import ciao_contrib.logger_wrapper as lw

lgr = lw.initialize_logger(toolname)
v0 = lgr.verbose0
v1 = lgr.verbose1
v2 = lgr.verbose2
v3 = lgr.verbose3

valid_chars = string.ascii_letters + string.digits + '_'

help_str = f"""
Convert XSPEC user models into a form usable by Sherpa.

This is *experimental* code and has seen limited testing. It does not
support all possible XSPEC user models at this time; please contact
the CXC HelpDesk at https://cxc.harvard.edu/helpdesk/ if you are
unable to compile a model.

The required arguments are

  1) The name to use for the Python module name; this will be used
     in the 'import <module name>.ui' line to load the models into
     Sherpa. It should not match the name of one of the models.

  2) The XSPEC definition file for the model (or models), which
     is often called model.dat or lmodel.dat

Files that match

  Fortran: *.f *.f03 *.f90
  C:       *.c
  C++:     *.cxx *.C *.cc *cpp

are automatically compiled. The order of compilation is done
alphabetically, as this appears to be what XSPEC does. To include
other files on the link line - e.g. .o files - add there names on the
command line.

So, if the model is defined in lmodel.dat and the source code is in
mdl1.f and mdl2.f then you could run this script as

  {toolname} mymodel lmodel.dat

and, once it has finished, you would say, within a Sherpa session,

  sherpa> import mymodel.ui

to load the models. The default behavior is to install the models into
your global set of Python packages, so the above can be run from any
directory. If you use the --local flag then you need to either

  a) be in the directory from which you ran {toolname}

  b) you have changed the Python path - by editing the PYTHONPATH
     environment variable or the os.sys.path array - to include this
     directory.

Note that some models may require data files in the working directory,
or for you to set up environment variables.

If the models fail to compile then you can get more information by
running

  python setup.py build

"""

copyright_str = """
Copyright (C) 2012, 2013, 2014, 2015, 2016, 2020, 2021, 2022
Smithsonian Astrophysical Observatory

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
02110-1301 USA.
"""


PYTHON_HEADER = """#
# This code is placed into the PUBLIC DOMAIN.
# Please contact the CXC Helpdesk if you have problems
# https://cxc.harvard.edu/helpdesk/
#
"""

CXX_HEADER = """//
// This code is placed into the PUBLIC DOMAIN.
// Please contact the CXC Helpdesk if you have problems
// https://cxc.harvard.edu/helpdesk/
//
"""


# ASCDS_OTS is not set for all shells (it is for csh/tcsh but not
# for bash), so use ASCDS_INSTALL/ots instead. By this point
# we know ASCDS_INSTALL exists, so don't bother providing a nice
# error message if os.getenv returns None
#
ASCDS_INSTALL = os.getenv("ASCDS_INSTALL")


def mkdir(outdir):
    """Create the output directory if it doesn't exist"""

    if os.path.isdir(outdir):
        return

    v3(f"Creating directory: {outdir}")
    os.mkdir(outdir)


def check_clobber(fname):
    """Error out if we can't clobber the file."""

    if not os.path.exists(fname):
        return

    raise IOError(f"The file {fname} exists and --clobber is not set.")


def save(outfile, txt):
    """Save the text to the file.

    Parameters
    ----------
    outfile : str
        The file name.
    txt : str
        The file contents.
    """

    v3(f"Creating {outfile}")
    with open(outfile, 'w') as fh:
        fh.write(txt)


def find_xspec_basedir():
    """Where are the XSPEC include files found?

    The script returns the first match to the directory

      <$ASCDS_INSTALL>/ots          <ciao-install>
      <$ASCDS_INSTALL>/             <conda>

    (relying in the fact there's no ots/ dir in conda), and we check
    there's

      - include/ and lib/ dirs
      - the file lib/libXS\* present.

    We then return the path, and it is guaranteed to be an absolute
    path. So, the includes should be in /include and the libraries in
    /lib relative to this path.

    """

    # At present there's only one path looked for
    v3("Looking for XSPEC includes in:")
    out = None
    for dname in ["ots", ""]:
        path = os.path.join(ASCDS_INSTALL, dname)
        v3(f"  - {path}")
        if os.path.isdir(path):
            out = path
            break

    v3(f"-> {out}")
    if out is None:
        raise OSError(f"Unable to find the XSPEC directory: {ASCDS_INSTALL}")

    libdir = os.path.join(out, 'lib')
    incdir = os.path.join(out, 'include')
    for path in [libdir, incdir]:
        if not os.path.isdir(path):
            raise OSError(f'Unable to find {path} or not a directory')

    matches = glob.glob(os.path.join(libdir, 'libXS*'))
    if len(matches) == 0:
        raise OSError(f'Unable to find libXS* in {libdir}')

    return os.path.abspath(out)


def validate_namefunc(namefunc):
    """Raise a ValueError if namefunc does not capitalize the return string."""
    inval = 'bob'
    outval = namefunc(inval)
    if not outval[0].isupper():
        raise ValueError(f"The namefunc routine does not capitalize the return value - e.g. '{inval}' -> '{outval}'.")


def add_prefix(prefix, inval):
    """Returns prefix prepended to inval (converting it to a string if
    necessary)."""
    return f"{prefix}{inval}"


def add_xsum_prefix(inval):
    """Returns XSUM prepended to inval (converting it to a string if
    necessary)."""
    return add_prefix("XSUM", inval)


def no_prefix(inval):
    """Returns inval converted to a string, after converting
    the first character to upper case.
    """
    return str(inval).capitalize()


def find_file_types(types):
    """Return a dictionary listing the types of files in the types
    dictionary, which has key as the type name and value as the glob
    pattern - e.g.

      types = { "generic": "*.f", "90": "*.f90" }

    Only those types that contain a match are included; if there are
    no matches then None is returned. The return names are sorted
    alphabetically.

    At present it turns out that it is possible to create the pattern
    from the typename, ie a dictionary is not needed as input, but
    leave as is as there is no need to "optimise" this.

    """

    out = {}
    for (typename, pattern) in types.items():
        match = glob.glob(pattern)
        if len(match) > 0:
            # It looks like XSPEC uses alphabetical sorting so do this
            # here (needed for reltrans to compile the F90 code in the
            # correct order).
            out[typename] = sorted(match)

    if len(out) == 0:
        return None
    else:
        return out


def find_fortran_files():
    """Return the Fortran files found in the current
    directory, labelled by "type".

      "f":   *.f
      "f03": *.f03
      "f90": *.f90

    The dictionary only contains keys if there was a
    match for that pattern; if there are no matches
    then None is returned.
    """

    return find_file_types({"f": "*.f",
                            "f03": "*.f03",
                            "f90": "*.f90"})


def find_c_files():
    """Return the C files found in the current
    directory, labelled by "type".

      "c": *.c

    The dictionary only contains keys if there was a
    match for that pattern; if there are no matches
    then None is returned.

    Note that on case-insensitive file systems, this
    will match the same files as find_c_files() for
    the "C" and "c" options.
    """

    return find_file_types({"c": "*.c"})


def find_cplusplus_files():
    """Return the Fortran files found in the current
    directory, labelled by "type".

      "cxx" : *.cxx
      "C"   : *.C
      "cc"  : *.cc
      "cpp" : *.cpp

    The dictionary only contains keys if there was a
    match for that pattern; if there are no matches
    then None is returned.

    Note that on case-insensitive file systems, this
    will match the same files as find_c_files() for
    the "C" and "c" options.
    """

    return find_file_types({"cxx": "*.cxx",
                            "C": "*.C",
                            "cc": "*.cc",
                            "cpp": "*.cpp"})


def count_nfiles(label, fileinfo):
    """Display, at verbose=1, the number of files
    found for this file type (combining all the
    different types). At verbose=2 lists the files found.

    Returns the number.
    """

    if fileinfo is None:
        v1(f"Found no {label} files.")
        return 0

    ntot = 0
    for (k, vs) in fileinfo.items():
        n = len(vs)
        ntot += n
        if n == 1:
            v2(f"Found one *.{k} file")
        else:
            v2(f"Found {n} *.{k} files")
        for v in vs:
            v2(f"  {v}")

    v2("")
    if ntot == 1:
        v1(f"Found one {label} file.")
    else:
        v1(f"Found {ntot} {label} files.")

    return ntot


def build_setup(modname, sources, fortransources, extrafiles,
                version,
                clobber=False,
                license='License :: CC0 1.0 Universal (CC0 1.0) Public Domain Dedication'):
    """Create the setup.py file.

    This is based on the work done in [1]_.

    Parameters
    ----------
    modname : str
        The module name.
    sources : list of str
        The paths to the source files, excluding the FORTRAN files.
        It can be the empty list, but then fortransources must not be
        empty.
    fortransources : list of str
        The paths to the FORTRAN source files.  It can be the empty
        list, but then sources must not be empty.
    extrafiles : list of str
        Extra files. What are we to do with these?
    version : str
        The version number (dotted values).
    clobber : bool, optional
        Do we over-write existing files or error out if they exist.
    license : str, optional
        The license for the module for the setup.py file.

    Notes
    -----
    A rather hacky way to build the XSPEC local model code, which is a
    collection of C++ and FORTRAN, and take advantage of the interface
    that the Sherpa XSPEC model uses (that handles the conversion from
    the user-supplied grid to the one that XSPEC needs).

    A large complication is that I want to compile FORTRAN code and
    link it into the extension, but do not want any Python interface
    to this code. My experiments to stop f2py from creating such an
    interface have been fruitless so far. So this module manually
    compiles the FORTRAN code and then tells the Extension to link in
    the object file. I have tried to integrate this into the "command"
    system of the build process, but perhaps I should just treat the
    FORTRAN code as creating a separate library that needs to be
    compiled as part of the build?

    References
    ----------

    .. [1] https://github.com/DougBurke/xspeclmodels

    """

    if extrafiles != []:
        raise ValueError("Unable to support extrafiles at this time")

    setupname = "setup.py"
    setupcfg = "setup.cfg"
    pyproject = "pyproject.toml"
    if not clobber:
        check_clobber(setupname)
        check_clobber(setupcfg)
        check_clobber(pyproject)

    modname_slashes = modname.replace('.', '/')

    # Copy over the source files
    #
    mkdir('src')
    outdir = 'src/_xspeclmodels'
    mkdir(outdir)

    srcnames = []
    fortnames = []
    for f in sources:
        v3(f" - copying over source file {f}")
        if not os.path.isfile(f):
            raise OSError(f"Unable to find source name '{f}'")

        outname = os.path.join(outdir, os.path.basename(f))
        if not clobber:
            check_clobber(outname)

        shutil.copy(f, outname)
        srcnames.append(outname)

    for f in fortransources:
        v3(f" - copying over FORTRAN file {f}")
        if not os.path.isfile(f):
            raise OSError(f"Unable to find FORTRAN file '{f}'")

        outname = os.path.join(outdir, os.path.basename(f))
        if not clobber:
            check_clobber(outname)

        shutil.copy(f, outname)
        fortnames.append(outname)

    if len(srcnames) == 0 and len(fortnames) == 0:
        raise ValueError("Should not have got here as no source/FORTRAN files to process")

    # Where are the XSPEC include files we may need? These are
    # included in the contrib code.
    #
    xspec_basedir = find_xspec_basedir()

    # We send in the sherpa.get_include_path so that we do not need to
    # build and install a version of Sherpa that we then immediately
    # throw away. This may need to be re-evaluated if we ever need
    # more functionality from Sherpa.
    #
    sherpa_include = sherpa.get_include()

    v2(f"  xspec basedir:    {xspec_basedir}")
    v2(f"  sherpa includes:  {sherpa_include}")

    # Let's find the version names of the XSPEC libraries:
    # hdsp_xxx, CCfits_xxx
    #
    # How clever should we be here?
    #
    suffix = sysconfig.get_config_var("SHLIB_SUFFIX")
    if suffix is None:
        suffix = ".so"

    def find_libname(head):
        libdir = Path(xspec_basedir) / 'lib'
        if not libdir.is_dir():
            raise OSError(f"XSPEC lib dir not found or not a directory: {libdir}")

        # For now assume the library is always versioned.
        #
        match_path = libdir / f"lib{head}_*{suffix}"
        matches = glob.glob(str(match_path))
        if len(matches) == 0:
            raise OSError(f"Unable to find {match_path}")

        if len(matches) > 1:
            raise OSError(f"Multiple matches for {match_path}")

        v2(f"   - found: {head:8s}  {matches[0]}")
        out = Path(matches[0]).stem
        return out[3:]  # drop the "lib" prefix

    hdsp_version = find_libname("hdsp")
    ccfits_version = find_libname("CCfits")

    date = time.asctime()
    out = f"""# Auto-generated by convert_xspec_user_model
# Version: {toolver}
# Sherpa: {sherpa.__version__}
# Date: {date}

import os

import setuptools

# What do we do now python has deprecated distutils? For the
# moment I would like to just jump to numpy versions but
# things are never that simple...
#
from distutils.core import Extension
from distutils.command.build_ext import build_ext

import numpy
from numpy.distutils import fcompiler

# from numpy.distutils.core import Extension
# from numpy.distutils.command.build_ext import build_ext


this_incpath = os.getcwd()
numpy_incpath = numpy.get_include()
sherpa_incpath = "{sherpa_include}"

# Where do we take the XSPEC includes from?
#
xspec_incpath = "{xspec_basedir}/include"

includes = [this_incpath, numpy_incpath, sherpa_incpath, xspec_incpath]

# Add in XSPEC-specific directories that it appears are needed by
# XSPEC local models - this is a hack and hopefully can go away
# with the changes made to 12.12.0 but given the timescales I
# think is likely to remain for a long time.
#
for path in ['XSFunctions', 'XSFunctions/Utilities']:
    includes.append(f'{{xspec_incpath}}/{{path}}')

# Check the includes
#
for include in includes:
    if not os.path.isdir(include):
        raise IOError(f"Unable to find {{include}} or not a directory")

# Where are the XSPEC libraries?
#
# They are located in different places in ciao-install vs conda,
# but for now concentrating on conda and - on Linux at least -
# the path doesn't appear to be needed
#
libs = []

# The choice of libs depends on the XSPEC model library version,
# which makes this harder to write than I'd like.
#
# The list is based on
# - Appendix F: Using the XSPEC Models Library in Other Programs
#   https://heasarc.gsfc.nasa.gov/xanadu/xspec/manual/
# - looking at the link line created by XSPEC initpackage
#
libnames = ["XSModel", "XSFunctions", "XSUtil", "XS",
            "{hdsp_version}", "{ccfits_version}", "cfitsio"]

# What FORTRAN code needs compiling?
#
FORTRANFILES = {fortnames}

# Seems to be needed on macOS, otherwise link time creates this
# message:
#
# ld: warning: could not create compact unwind for _zrunkbb_: stack subq instruction is too different from dwarf stack size
#
# No idea if this breaks anything (more likely to slow the execution of
# the code, from what the internet tells me).
#
# Is this worth it? '-Wl,-flat_namespace,-undefined,dynamic_lookup'
#
if os.uname().sysname == 'Darwin':
    cargs = ['-Wl,-no_compact_unwind']
else:
    cargs = []

# Do we need this?
# cargs.append('-lgfortran')

mod = Extension('{modname}._models',
                include_dirs=includes,
                library_dirs=libs,
                libraries=libnames,
                sources=['src/{modname_slashes}/src/_models.cxx']
                        +
                        {srcnames},
                extra_link_args=cargs,
                depends=FORTRANFILES
                )

# TODO:
#
# This could be made more generic by inspecting the sources sent
# in to it, and pulling out the FORTRAN code from it. It also always
# recompiles the FORTRAN code, even if it hasn't changed, but then
# doesn't do anything with it.
#
# Should I really be looking at build_clib for inspiration, guidance,
# and fashion tips?
#
class ExtBuild(build_ext):

    def run(self):

        # Manually compile the FORTRAN code; this is all a bit too
        # hand coded
        #
        cmplr = fcompiler.new_fcompiler()
        cmplr.customize()

        # Try to let included files work
        cmplr.add_include_dir(this_incpath)

        # Try to support XSPEC compiler options (this has only been tested
        # with conda, and only with a model wanting FFTW)
        #
        cmplr.add_include_dir(xspec_incpath)

        self.announce('Compiling FORTRAN code', level=2)  # used to be log.INFO
        fobjs = cmplr.compile(FORTRANFILES,
                              output_dir=self.build_temp,
                              debug=self.debug)

        # Could just append if set, but for now expect not to be
        # set, so error out if this changes
        #
        assert self.link_objects is None, \\
            f'unexpected: link_objects={{self.link_objects}}'
        self.link_objects = fobjs

        super().run()


kwargs = {{
    'ext_modules': [mod],
}}

# Only bother if we have any FORTRAN files to compile
if len(FORTRANFILES) > 0:
    kwargs['cmdclass'] = {{'build_ext': ExtBuild}}

setuptools.setup(**kwargs)
"""

    save(setupname, out)

    # Create the setup.cfg file
    #
    out = f'''[metadata]
name = {modname}
author = Douglas Burke
version = {version}
description = XSPEC user models in Sherpa
classifiers =
    {license}
    Intended Audience :: Science/Research
    Programming Language :: Python :: 3.7
    Programming Language :: Python :: 3.8
    Programming Language :: Python :: 3.9
    Programming Language :: Python :: Implementation :: CPython
    Topic :: Scientific/Engineering :: Astronomy
    Topic :: Scientific/Engineering :: Physics
    Development Status :: 3 - Alpha

[options]
zip_safe = False

packages = find:
package_dir =
    =src

[options.packages.find]
where = src
'''
    save(setupcfg, out)

    # Create the pyproject.toml file. As we send in the Sherpa
    # include path from the installed Sherpa we do not need to
    # build a version of Sherpa, which saves time.
    #
    out = f'''[build-system]
requires = ["setuptools >= 49.1.2",
            "wheel",
            "oldest-supported-numpy"
           ]
build-backend = "setuptools.build_meta"
'''
    save(pyproject, out)


def build_module_ui(modname, clobber=False):
    """Create the ui module for the module."""

    modname_slashes = modname.replace('.', '/')
    outfile = f"src/{modname_slashes}/ui.py"
    if not clobber:
        check_clobber(outfile)

    out = PYTHON_HEADER
    out += f'''
"""
Provide access to the local models when using the Sherpa UI
layer.

The added models are reported to the user using Sherpa's logger
at the logging.INFO level. If the model exists in Sherpa's XSPEC
module then we skip it here.

"""

import logging

import sherpa.astro.ui
import sherpa.astro.xspec

import {modname}

logger = logging.getLogger('sherpa')

# What models do we know about?
#
xsmodels = {{n for n in dir(sherpa.astro.xspec)
            if n.startswith('XS')}}

for name in {modname}.__all__:
    if name in xsmodels:
        logger.info(f"Skipping local model as clashes with XSPEC {{name.lower()}}")
        continue

    cls = getattr({modname}, name)
    sherpa.astro.ui.add_model(cls)

    # Change the message based on the model type
    if issubclass(cls, sherpa.astro.xspec.XSAdditiveModel):
        mtype = "additive"
    elif issubclass(cls, sherpa.astro.xspec.XSConvolutionKernel):
        mtype = "convolution"
    elif issubclass(cls, sherpa.astro.xspec.XSMultiplicativeModel):
        mtype = "multiplicative"
    else:
        mtype = "unknown"

    msg = f"Adding {{mtype:14s}} XSPEC local model: {{name.lower()}}"
    logger.info(msg)
'''

    save(outfile, out)


def build_module_init(modname, pycode, mdls,
                      modelfile,
                      infiles,
                      extrafiles,
                      version,
                      clobber=False):
    """Create the module initalization code.

    Parameters
    ----------
    modname : str
        The Python module name.
    mdls : sequence of ModelDefintion objects
        The models to process. We should not need to send this in.
    pycode : str
        The Python code representing the models, created by
        xspec.create_xspec_code.
    modelfile : str
        The name of the XSPEC model file.
    infiles : lst of str
        The model files.
    extrafiles : list of str
        ny extra files
    version : str
        The version number (dotted values).
    clobber : bool, optional
        Do we over-write existing files or error out if they exist.

    """

    modname_slashes = modname.replace('.', '/')
    outfile = f"src/{modname_slashes}/__init__.py"
    if not clobber:
        check_clobber(outfile)

    mdlnames = []
    atypes = []
    mtypes = []
    ctypes = []
    modeltypes = set()
    languages = set()
    for mdl in mdls:
        if mdl.modeltype == 'Add':
            modeltypes.add('XSAdditiveModel')
            ary = atypes
        elif mdl.modeltype == 'Con':
            modeltypes.add('XSConvolutionKernel')
            ary = ctypes
        elif mdl.modeltype == 'Mul':
            modeltypes.add('XSMultiplicativeModel')
            ary = mtypes
        else:
            raise ValueError(f"Unsupported model type {mdl.modeltype}")

        languages.add(mdl.language)
        mdlnames.append(f"'{mdl.clname}'")  # want to display strings im Python
        ary.append(mdl.clname.lower())

    if len(mdlnames) == 0:
        raise ValueError("Somehow got this far with no models to process!")
    elif len(mdlnames) == 1:
        mdlnames = f"{mdlnames[0]},"
    else:
        mdlnames = ', '.join(mdlnames)

    xsnames = ", ".join(list(modeltypes))

    # Store the system info in case a user tries to run on
    # a different system to how it was built (this is for
    # diagnostic purposes only; it is not used as a test
    # anywhere). It is also only set for ciao-install installs
    #
    system_name = os.path.join(ASCDS_INSTALL, "ciao-type")
    try:
        system_info = open(system_name, "r").read()
    except IOError:
        system_info = "unknown"

    system_info = system_info.split('\n')[0]

    # Do we need to include Parameter (i.e. do we have a norm parameter)?
    #
    if 'XSAdditiveModel' in modeltypes:
        normpar = "Parameter, "
    else:
        normpar = ""

    out = PYTHON_HEADER
    out += f'''
"""Sherpa interfaces to XSPEC models."""

from sherpa.models.parameter import {normpar}hugeval
from sherpa.astro.xspec import {xsnames}, XSParameter, get_xsversion

from . import _models

__all__ = ({mdlnames})

# We need to ensure that the XSPEC model library has been initialized
# before the model is evaluated. This could be handled in the
# Python<->C++ bridge, as it is with the XSPEC module that is
# distributed with CIAO, but here we just ensure that the library
# has been initialized when this module is imported.
#
get_xsversion()

# Provenance
#
'''

    # Note: the separation between "build info" and the rest is
    #       not clear
    out += "\n".join(["provenance = {",
                      f"  'date': '{time.asctime()}'",
                      f"  , 'buildinfo': {{ 'tool': '{toolname}', ",
                      f"'version': '{toolver}', ",
                      f"'sherpaversion': '{sherpa.__version__}', ",
                      f"'ASCDS_INSTALL': '{ASCDS_INSTALL}', ",
                      f"'ciaotype': '{system_info}', ",
                      f"'machine': '{os.uname()[1]}' }}",
                      f"  , 'modulename': '{modname}'",
                      f"  , 'moduleversion': '{version}'",
                      f"  , 'modelfile': '{modelfile}'",
                      f"  , 'files': {infiles}",
                      f"  , 'extrafiles': {extrafiles}",
                      f"  , 'dir': '{os.getcwd()}'",
                      f"  , 'additive': {atypes}",
                      f"  , 'multiplicative': {mtypes}",
                      f"  , 'convolve': {ctypes}",
                      f"  , 'langs': {list(languages)}",
                      "}"])

    out += '''

# Class definitions
#
'''

    # Fix an error in Sherpa 4.15.0 and earlier.
    # - replace "{t2}" by "        "
    #
    import re
    conv = re.subn(r"\{t2\}", "        ", pycode)
    if conv[1] > 0:
        pycode = conv[0]
        v2(f"NOTE: had to correct the python code {conv[1]} times")

    out += pycode

    save(outfile, out)


def build_module_cxx(modname, cxxcode, mdls, clobber=False):
    """Create the C++ module code.

    Parameters
    ----------
    modname : str
        The Python module name.
    cxxcode : str
        The C++ code created by xspec.create_xspec_code.
    mdls : sequence of ModelDefintion objects
        The models to process.
    clobber : bool, optional
        Do we over-write existing files or error out if they exist.

    """

    # Do we have any C++ models?
    #
    have_cxx = []
    have_c = []
    for mdl in mdls:
        if mdl.language == 'C++ style':
            have_cxx.append(mdl)
        elif mdl.language == 'C style':
            have_c.append(mdl)

    modname_slashes = modname.replace('.', '/')
    outdir = f"src/{modname_slashes}/src"
    mkdir(outdir)

    outfile = f"{outdir}/_models.cxx"
    if not clobber:
        check_clobber(outfile)

    out = CXX_HEADER
    out += '''
// Provide the Python interface to XSPEC local models using Sherpa.

#include <iostream>

#include <xsTypes.h>
#include <XSFunctions/Utilities/funcType.h>  // defines xsccCall

// What XSPEC version do we support
'''

    # Declare the XSPEC defines used to control the code; this is a
    # bit OTT as we know we don't need all of them, but put them all
    # in for now. This needs to be updated with each CIAO release.
    #
    xspec_version_str = get_xsversion()
    v1(f"Using XSPEC version: {xspec_version_str}")

    toks = xspec_version_str.split(".")
    if len(toks) != 3:
        raise ValueError(f"Unrecognized XSPEC version: {xspec_version_str}")

    # assume the micro version is 1 digit
    #
    xspec_version = (int(toks[0]), int(toks[1]), int(toks[2][:1]))

    for v in [(12, 9, 0), (12, 9, 1),
              (12, 10, 0), (12, 10, 1),
              (12, 11, 0), (12, 11, 1),
              (12, 12, 0), (12, 12, 1)]:
        if v <= xspec_version:
            out += "#define XSPEC_{}_{}_{}\n".format(*v)

    out += '''
#include "sherpa/astro/xspec_extension.hh"

'''

    if len(have_cxx) > 0:
        # cppModelWrapper is defined in XSFunctions/funcWrappers.cxx
        # so should be available in libXSFunctions. It doesn't appear
        # to be declared in an include file so we need ot specify it
        # explicitly.
        #
        out += '''void cppModelWrapper(const double* energy, int nFlux, const double* params,
       int spectrumNumber, double* flux, double* fluxError, const char* initStr,
       int nPar, void (*cppFunc)(const RealArray&, const RealArray&,
       int, RealArray&, RealArray&, const string&));

'''

        # Does this ever get closed? Or is it a bug?
        out += '''extern "C" {
'''

        for cxxmdl in have_cxx:

            out += f'  void {cxxmdl.funcname}'
            out += '(const RealArray& energyArray, const RealArray& params, int spectrumNumber, RealArray& flux, RealArray& fluxErr, const string& initString);\n'

            out += f'  void C_{cxxmdl.funcname}'
            out += '(const double* energy, int nFlux, const double* params, int spectrumNumber, double* flux, double* fluxError, const char* initStr) {\n'
            out += f'    const size_t nPar = {len(cxxmdl.pars)};\n'
            out += '    cppModelWrapper(energy, nFlux, params, spectrumNumber, flux, fluxError, initStr, nPar, '
            out += f'{cxxmdl.funcname});\n'
            out += '  }\n'

        out += '''
}
'''

    # This is needed to wrap relline. Is it needed for other
    # models? Hopefully it doesn't mess anything up as it's
    # just declaring symbols.
    #
    if len(have_c) > 0:
        out += 'extern "C" {\n'

        for cmdl in have_c:
            out += f'  xsccCall {cmdl.funcname};\n'

        out += "}\n"

    out += cxxcode

    # This should be fixed in Sherpa but work around it here.
    if not cxxcode.endswith(';'):
        out += ';\n'

    out += '''static struct PyModuleDef wrapper_module = {
  PyModuleDef_HEAD_INIT,
  "_models",
  NULL,
  -1,
  Wrappers,
};

// Note that we are going to assume that the XSPEC model has
// already been initialized. The XSPECMODELFCT_C macro/template
// does not guarantee this (it does when building the Sherpa
// XSPEC module, but not for external code, since INIT_XSPEC
// may not be defined).
//
PyMODINIT_FUNC PyInit__models(void) {
  import_array();
  return PyModule_Create(&wrapper_module);
}
'''

    save(outfile, out)


def build_module(modname, mdls, modelfile, infiles, extrafiles,
                 version,
                 clobber=False):
    """Create the module files.

    This does not copy over the source files as that is done by
    build_setup().

    Parameters
    ----------
    modname : str
        The Python module name.
    mdls : sequence of ModelDefintion objects
        The models to process.
    modelfile : str
        The name of the XSPEC model file.
    infiles : lst of str
        The model files.
    extrafiles : list of str
        ny extra files
    version : str
        The version number (dotted values).
    clobber : bool, optional
        Do we over-write existing files or error out if they exist.

    """

    xdata = xspec.create_xspec_code(mdls)

    outdir = 'src'
    mkdir(outdir)

    for cpt in modname.split('.'):
        outdir += f'/{cpt}'
        mkdir(outdir)

    build_module_ui(modname, clobber=clobber)
    build_module_init(modname, xdata.python, mdls,
                      modelfile, infiles, extrafiles, version,
                      clobber=clobber)
    build_module_cxx(modname, xdata.compiled, mdls, clobber=clobber)


def compile_module(local=False, verbose=False):
    """Build the module calling out to setup.py.

    Parameters
    ----------
    local : bool, optional
        If set then only build "locally" - i.e. a develop build -
        rather than installing into the Python packaging system.
    verbose : bool, optional
        If set to True then report the build steps

    """

    args = ['pip', 'install']
    if local:
        args.append('-e')
    if verbose:
        args.append('--verbose')

    args.append('.')

    v3(f"Building with: {' '.join(args)}")
    rval = sbp.call(args)
    if rval != 0:
        raise ValueError(f"Unable to run {args}\n")


@lw.handle_ciao_errors(toolname, toolver)
def convert_xspec_user_model(modulename, modelfile,
                             extrafiles=None,
                             clobber=False,
                             local=False,
                             version='1.0',
                             namefunc=add_xsum_prefix,
                             verbose=False):
    """Create a Python module called modulename that allows the
    XSPEC user model - defined by the model file (e.g.
    modelfile='lmodel.dat') - using the code found in the following
    files in the directory:

      Fortran: *.f *.f03 *.f90
      C:       *.c
      C++:     *.cxx *.C *.cc *.cpp

    It creates (using the clobber to determine whether to continue if
    the files already exist):

        src/<modulename>/__init__.py
        src/<modulename>/ui.py

    and, when local=True

        build/ (and contents)
        src/<modulename>/_models.cpython-xxx.so

    Parameters
    ----------
    modulename : str
        The Python module name. It is assumed to normally be a single
        term but it can include "." such as "xspec.galactic".
    modelfile : str
        The name of the XSPEC model file (e.g. "lmodel.dat").
    extrafiles : list of str or None, optional
        At the moment this is unused. The idea is to be able to send in
        extra files, but for the moment we require them to be in the
        local directory (so picked up automatically).
    clobber : bool, optional
        Do we over-write existing files or error out if they exist.
    local : bool, optional
        If True then use a "develop" build (pip install -e .) and if
        False a full install (pip install .).
    version : str, optional
        The version number (dotted values). The default is '1.0'.
    namefunc : function reference, optional
        The function that is used to convert the XSPEC model name to the
        Sherpa model class name. The default is add_xsum_prefix but
        options are no_prefix and add_prefix, which would need to be
        partialy applied. The first character of the returned string
        must be in upper case.
    verbose : bool, optional
        Should the build stop report the steps? I may decide to change
        quite what this controls.

    """

    # Although extrafiles is sent in, at the moment we do not use it. This means
    # that we expect to use only files in the worknig directory.
    #
    if extrafiles is not None:
        raise NotImplementedError("extrafiles is not currently supported")

    extrafiles = []

    v2(f"{toolname}: {toolver}")
    v2(f"  name:       {modulename}")
    v2(f"  modelfile:  {modelfile}")
    # v2(f"  extrafiles: {extrafiles}")
    v2(f"  clobber:    {clobber}")
    v2("")

    # When local is False ensure that the modulename is "unique". We
    # want to allow the user to re-use the same module name (e.g.
    # when developing or updating code), so we use the provenance
    # field in the module to check if this is the case.
    #
    if not local:
        v2(f"Checking if import {modulename} already exists")
        try:
            module = importlib.import_module(modulename)
            try:
                known = module.provenance['buildinfo']['tool'] == toolname
                modver = module.provenance['moduleversion']
            except (AttributeError, KeyError):
                known = False

            if known:
                v2(f" - found version {modver}")
            else:
                raise ValueError(f"The module name '{modulename}' appears to " +
                                 "already exist. Please use a different name.")

        except ImportError:
            pass

    # find source-code files; perhaps the cpp_files check should be
    # done before the c_files one to ensure that .c/.C files always
    # get treated as C++ on case-insensitive systems; not clear what
    # order XSPEC/initpackage does this since it depends on the
    # Makefile rules
    #
    fortran_files = find_fortran_files()
    c_files = find_c_files()
    cpp_files = find_cplusplus_files()
    n_fortran = count_nfiles("Fortran", fortran_files)
    n_c = count_nfiles("C", c_files)
    n_cpp = count_nfiles("C++", cpp_files)

    if sum([n_fortran, n_c, n_cpp]) == 0:
        raise IOError(f"No Fortran/C/C++ files found in {os.getcwd()}")

    # for now do not treat the different types differently; this may change
    allfiles = []
    for d in [fortran_files, c_files, cpp_files]:
        if d is None:
            continue

        for vs in d.values():
            allfiles.extend(vs)

    v3(f"Processing the following {len(allfiles)} source code file(s):")
    v3("  {}".format("\n  ".join(allfiles)))
    v3("")

    for f in extrafiles:
        if not os.path.exists(f):
            raise IOError(f"Unable to find file {f}")

    validate_namefunc(namefunc)

    # Unlike earlier versions of convert_xspec_user_model we do not
    # check compiled files when clobber is not set.

    mdlinfo = xspec.parse_xspec_model_description(modelfile, namefunc=namefunc)

    # Strip out models that call the same function. This is a somewhat
    # odd check, and could perhaps be done after other checks, but I
    # do it first. It could just ignore those models for which the
    # number of parameters is different, but as in that case it's
    # really just an alias for the model it doesn't seem worth it,
    # and better to skip the possible error.
    #
    # This was added to handle processing the XSPEC model file from
    # 12.8.2, which has the eplogpar model (2 params) calling the
    # logpar model - presumably by accident (bug report has been sent
    # to Keith) - which accepts 3 parameters. Since the wrapper code
    # includes an invariant on the number of parameters, this would
    # complicate things, so for now exclude them. This particular
    # model has since been fixed in XSPEC, but the check remains,
    # even though it is also part of the xspec utility library.
    #
    funcnames = {}
    for mdl in mdlinfo:
        try:
            funcnames[mdl.funcname] += 1
        except KeyError:
            funcnames[mdl.funcname] = 1

    invalidnames = [k for (k, v) in funcnames.items() if v > 1]
    if len(invalidnames) > 0:
        mdls = []
        for mdl in mdlinfo:
            if mdl.funcname in invalidnames:
                v1(f"Skipping model {mdl.name} as it calls " +
                   f"{mdl.funcname} which is used by " +
                   f"{funcnames[mdl.funcname]} different models")
            else:
                mdls.append(mdl)

        mdlinfo = mdls

    # Strip out unsupported models and check on the model names.
    #
    known_models = ui.list_models()
    known_symbols = dir(ui)

    mdls = []
    mnames = []
    probs = []
    langs = set()
    for mdl in mdlinfo:
        v3(f" - checking model {mdl.name}")

        if mdl.modeltype in ['Mix', 'Acn']:
            v1(f"Skipping {mdl.name} as model type = {mdl.modeltype}")
            continue

        # The following check should never fire, but leave in
        if mdl.language not in ['Fortran - single precision',
                                'Fortran - double precision',  # un-tested
                                'C style', 'C++ style']:
            v1(f"Skipping {mdl.name} as language = {mdl.language}")
            continue

        # TODO: should there be a more-extensive naming scheme, and
        #       should this error out?
        lname = mdl.clname.lower()
        if lname == modulename:
            pstr = f"model class {mdl.clname} has the " + \
                   "same name as the module, which may cause problems"
            v1("WARNING: " + pstr)
            probs.append(pstr)

        if lname in known_models:
            pstr = f"model {mdl.name} has the same name as the existing model {lname}"
            v1("WARNING: " + pstr)
            probs.append(pstr)

        nflags = len(mdl.flags)
        if nflags > 0:
            v3(f" - at least one model flag; [0] = {mdl.flags[0]}")
            if mdl.flags[0] == 1:
                probs.append(f"model {mdl.name} calculates model variances; this is untested/unsupported in Sherpa")

            if nflags > 1 and mdl.flags[1] == 1:
                v3(f" - at least two model flags; [1] = {mdl.flags[1]}")
                probs.append(f"model {mdl.name} needs to be re-calculated per spectrum; this is untested.")

        langs.add(mdl.language)
        mdls.append(mdl)
        mnames.append(lname)

    nmdl = len(mdls)
    if nmdl == 0:
        raise ValueError("No supported models were found!")

    if nmdl == 1:
        v1("Processing one model.")
    else:
        v1(f"Processing {nmdl} models.")

    langs = sorted(list(langs))
    if len(langs) == 1:
        v1(f"Using language interface: {langs[0]}")
    else:
        v1(f"Using language interfaces: {', '.join(langs)}")

    srcfiles = []
    for d in [c_files, cpp_files]:
        if d is None:
            continue

        for vs in d.values():
            srcfiles.extend(vs)

    fortfiles = []
    for d in [fortran_files]:
        if d is None:
            continue

        for vs in d.values():
            fortfiles.extend(vs)

    build_setup(modulename,
                srcfiles,
                fortfiles,
                extrafiles,
                version,
                clobber=clobber)
    build_module(modulename, mdls, modelfile, allfiles, extrafiles,
                 version,
                 clobber=clobber)

    # Set the verbose value if
    compile_module(local=local, verbose=verbose)

    # Test out whether we can import the model
    v1("")
    v1("Testing out importing the model ...")
    ierr = None
    try:
        v2(f"Trying to import {modulename}")

        if local:
            # Just in case the current directory is not in the path
            os.sys.path.insert(0, "src")

        importlib.import_module(modulename)
        v1("Import succeeded")

    except ImportError as exc:
        v0("")
        v0("Error: unable to import the module; possible reasons are:")
        v0("  - incompatible version of gcc/gfortran used.")
        v0("  - the model uses the udmget set of routines which are currently")
        v0("    unsupported")
        v0("  - missing a library or include directory")
        v0("")
        ierr = exc

    if ierr is None:
        v1("")
        v1("------------------------------------------------------------------")
        v1("")
        v1("Finished. You should be able to now say")
        v1(f"    import {modulename}.ui")
        v1("from Sherpa.")
        v1("")

        n = len(mnames)
        if n == 1:
            v1("The following model is available:")
        else:
            v1(f"The following {n} models are available:")

        v1("  {}".format("\n  ".join(mnames)))
        v1("")

    # report any problems
    if probs != []:
        n = len(probs)
        if n == 1:
            v1("Please note the following problem:")
        else:
            v1(f"Please note the following {n} problems:")

        v1("  {}".format("\n  ".join(probs)))
        v1("")

    if ierr is not None:
        raise ImportError(f"Unable to import model:\n{ierr}")


if __name__ == "__main__":

    parser = argparse.ArgumentParser(description=help_str,
                                     formatter_class=argparse.RawDescriptionHelpFormatter)

    parser.add_argument("name",
                        help="Name of Sherpa module")
    parser.add_argument("modelfile",
                        help="The XSPEC model definition file (eg lmodel.dat)")
    # parser.add_argument("extrafiles", nargs='*',
    #                     help="Additional files")

    parser.add_argument("--local", "-l", dest="local", action="store_true",
                        default=False,
                        help="Build the package locally rather than globally?; default is %(default)s")

    parser.add_argument("--prefix", "-p", dest="prefix", nargs='?',
                        default="XSUM", const=None,
                        help="Prefix for model names (empty or must start with a capital letter; default is %(default)s")

    parser.add_argument("--pyver", dest="pyver", type=str,
                        default="1.0",
                        help="The module version; default is %(default)s")

    parser.add_argument("--clobber", "-c", dest="clobber", action="store_true",
                        default=False,
                        help="Set to overwrite output files, otherwise script exits")
    parser.add_argument("--verbose", "-v", dest="verbose", type=int,
                        choices=range(0, 6), default=1,
                        help="Verbose level; higher for more screen output")

    parser.add_argument("--version", action="version",
                        version=toolver,
                        help="List the version date for the script and exit")
    parser.add_argument("--copyright", action="version",
                        version=copyright_str,
                        help="List the copyright for the script and exit")

    # support some development options
    arglist = lw.preprocess_arglist(sys.argv[1:])
    args = parser.parse_args(arglist)

    lw.set_verbosity(args.verbose)

    # Perhaps should do something else; eg namefunc=None means
    # use no_prefix (so that this can then be displayed at verbose=2
    # from within convert_xspec_user_model rather than here)?
    #
    if args.prefix is None:
        mkname = no_prefix
    else:
        if not args.prefix[0].isupper():
            # would like to make this appear the same as other errors
            # but this is outside the handle_ciao_errors wrapper.
            #
            sys.stderr.write(f"# {toolname} ({toolver}): " +
                             "ERROR the prefix argument must start with a " +
                             f"capital letter; sent {args.prefix}\n")
            sys.exit(1)

        def mkname(inval):
            return add_prefix(args.prefix, inval)

    # for some reason sys.tracebacklimit is 0, meaning no backtraces
    # when using --tracebackdebug/--debug
    sys.tracebacklimit = None

    # base verbose setting for the tool as input verbosity >= 2.
    verbose = args.verbose >= 2

    convert_xspec_user_model(args.name,
                             args.modelfile,
                             # extrafiles=args.extrafiles,
                             extrafiles=None,
                             clobber=args.clobber,
                             local=args.local,
                             version=args.pyver,
                             namefunc=mkname,
                             verbose=verbose)

# End

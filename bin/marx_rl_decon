#!/usr/bin/env python
# coding: utf-8
#
# Copyright (C) 2023 Smithsonian Astrophysical Observatory
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#


'Perform Richardson Lucy deconvolution using MARX to convolve data'

import os
import sys
from subprocess import check_output

from ciao_contrib.runtool import make_tool
import numpy as np
from pycrates import read_file
import paramio
import ciao_contrib.logger_wrapper as lw
from sherpa.utils import parallel_map


__toolname__ = "marx_rl_decon"
__revision__ = "19 July 2023"

np.seterr(divide='ignore', invalid='ignore')

lw.initialize_logger(__toolname__)
verb0 = lw.get_logger(__toolname__).verbose0
verb1 = lw.get_logger(__toolname__).verbose1
verb2 = lw.get_logger(__toolname__).verbose2
verb5 = lw.get_logger(__toolname__).verbose5


class Observation():
    'Class to  hold info about grid needed for each observation'

    X = 0
    Y = 1

    def __init__(self, eventfile, fovfile, asolfile, binsize, outroot):

        self.eventfile = eventfile
        self.fovfile = fovfile
        self.asolfile = asolfile
        self.outroot = outroot
        self.phys_center = None
        self.phys_limits = None
        self.bin_spec = None
        self.marx = None
        self.full_grid = None

        self.compute_aimpoint()
        self.compute_binspec(binsize)

    def compute_aimpoint(self):
        '''Get physical coords of optical axis. If reprojected then need
        to use wcs'''
        evt = read_file(self.eventfile)
        self.keys = {k: evt.get_key_value(k) for k in evt.get_keynames()}

        crval = [self.keys['RA_PNT'], self.keys['DEC_PNT']]

        eqpos = evt.get_transform("eqpos")  # Chandra data only, OK

        # pytransform requires and returns lists :(
        crpix = eqpos.invert([crval])
        self.phys_center = crpix[0]

    def compute_binspec(self, binsize):
        '''marx requires the center of the image be the aimpoint so we need
        to make the counts image centered correctly'''
        verb1("Computing binning specification")

        xcenter = np.rint(self.phys_center[self.X])
        ycenter = np.rint(self.phys_center[self.Y])

        gfl = make_tool("get_fov_limits")
        gfl(self.fovfile)
        xygrid = gfl.xygrid

        xgrid = [float(x) for x in xygrid.split(",")[0].split(":")[0:2]]
        xlen = np.array(xgrid)-xcenter
        xlen = max(np.abs(xlen))

        ygrid = [float(y) for y in xygrid.split(",")[1].split(":")[0:2]]
        ylen = np.array(ygrid)-ycenter
        ylen = max(np.abs(ylen))

        self.phys_limits = {'xlo': xcenter-xlen,
                            'xhi': xcenter+xlen,
                            'ylo': ycenter-ylen,
                            'yhi': ycenter+ylen,
                            'xlen': xlen,
                            'ylen': ylen,
                            'xcen': xcenter,
                            'ycen': ycenter,
                            }

        img_xgrid = f"x={xcenter-xlen}:{xcenter+xlen}:{binsize}"
        img_ygrid = f"y={ycenter-ylen}:{ycenter+ylen}:{binsize}"

        self.bin_grid = f"[bin {img_xgrid},{img_ygrid}]"
        verb2(self.bin_grid)

    def make_counts_image(self, full_grid):
        '''Create the counts image, img_0'''

        verb1("Making counts image centered on the aim point")

        self.outroot += f"_obsid{self.keys['OBS_ID']}"

        self.full_grid = full_grid
        outfile = f"{self.outroot}_counts.img"

        dmcopy = make_tool("dmcopy")
        dmcopy(f"{self.eventfile}{full_grid}[opt type=i4]", outfile,
               clobber=True)

        self.img0_filename = outfile

        dmstat = make_tool("dmstat")
        dmstat(outfile, centroid=False, sigma=False, median=False)
        self.counts = int(dmstat.out_sum)

    def make_marx_dot_par(self, energy, flux, randseed, marx_root):
        'Create marx parameter file for this obs'
        self.marx = Marx(energy, flux, randseed, marx_root)
        self.marx.make_marx_dot_par(self)

    def crop(self, infile, flip):
        'Crop image to center on aimpoint for this obs'
        outfile = f"{self.outroot}_crop.img"
        dmcopy = make_tool("dmcopy")
        dmcopy.infile = f"{infile}{self.bin_grid}"
        dmcopy.outfile = outfile
        dmcopy(clobber=True)

        if flip:
            # Flip
            verb1("\tflip(I_0/(I_n ⊙ P))")
            out_crate = read_file(outfile)
            out_vals = out_crate.get_image().values
            out_vals = np.flip(out_vals, axis=[0, 1])
            out_crate.get_image().values = out_vals
            outfile = f"{self.outroot}_cropflip.img"
            out_crate.write(outfile, clobber=True)
            go_rm(f"{self.outroot}_crop.img")

        return outfile

    def convolve_using_marx(self, infile, flip=False):
        'Convolve per obs image using marx'
        cropfile = self.crop(infile, flip)
        self.marx.run_marx(cropfile, flip)
        go_rm(cropfile)


class Marx():
    'Class to hold info needed to run marx'

    def __init__(self, energy, flux, randseed, marx_root):
        'init, save info'
        self.energy = energy
        self.flux = flux
        self.randseed = randseed
        self.marx_root = marx_root
        self.outroot = None
        self.marx_par = None

    def make_marx_dot_par(self, obsr):
        '''We run marx once (via simulate_psf) w/ dummy parameters just
        to get .par file setup'''

        self.outroot = obsr.outroot
        self.full_grid = obsr.full_grid
        self.bin_grid = obsr.bin_grid

        verb1("Setting up MARX parameter file")
        ra_pnt = obsr.keys['RA_PNT']
        dec_pnt = obsr.keys['DEC_PNT']

        sim_psf = make_tool("simulate_psf")
        sim_psf.infile = obsr.img0_filename
        sim_psf.outroot = obsr.outroot
        sim_psf.ra = ra_pnt
        sim_psf.dec = dec_pnt
        sim_psf.spectrumfile = ""
        sim_psf.monoenergy = self.energy
        sim_psf.random_seed = self.randseed
        sim_psf.flux = 1.0e-5
        sim_psf.marx_root = self.marx_root
        sim_psf.asolfile = obsr.asolfile
        ver_out = sim_psf(keepiter=True)

        if ver_out:
            verb2(ver_out)

        for suffix in [".psf", "_i0000.psf", "_i0000_projrays.fits",
                       "_projrays.fits"]:
            delme = f"{self.outroot}{suffix}"
            go_rm(delme)

        import glob
        marx_par = glob.glob(f"{sim_psf.outroot}*marx.par")
        self.marx_par = marx_par[0]

        # Setup for start of processing
        paramio.pset(self.marx_par, "SourceType", "IMAGE")
        paramio.pset(self.marx_par, "SourceFlux", str(self.flux))

    def run_marx(self, infile, flip):
        "Convolution is done using marx"

        paramio.pset(self.marx_par, "S-ImageFile", infile)
        paramio.pset(self.marx_par, "OutputDir", f"{self.outroot}_marxdir")
        delme = check_output([f"{self.marx_root}/bin/marx",
                              f"@@{self.marx_par}"])
        if delme:
            verb5(delme)

        delme = check_output(["marx2fits", f"{self.outroot}_marxdir",
                              f"{self.outroot}_marx.fits"])
        if delme:
            verb5(delme)

        # Reproject marx files to match tangent point of images
        reproject_events = make_tool("reproject_events")
        reproject_events.infile = f"{self.outroot}_marx.fits"
        reproject_events.outfile = f"{self.outroot}_reprojmarx.fits"
        reproject_events.random = "-1"
        reproject_events.match = infile
        reproject_events(clobber=True)

        dmcopy = make_tool("dmcopy")

        if flip:
            outfile = f"{self.outroot}_marxflip.img"
        else:
            outfile = f"{self.outroot}_marx.img"

        dmcopy(f"{self.outroot}_reprojmarx.fits{self.bin_grid}[opt type=i4]",
               outfile, clobber=True)

        # ~ # Make sure each pixel has at least '1' count
        # ~ dmimgadapt = make_tool("dmimgadapt")
        # ~ dmimgadapt.infile = f"{outroot}_marx.fits{bin_grid}[opt type=i4]"
        # ~ dmimgadapt.outfile = f"{outroot}_marx.img"
        # ~ dmimgadapt.function = "box"
        # ~ dmimgadapt.minrad = 1
        # ~ dmimgadapt.maxrad = 10
        # ~ dmimgadapt.numrad = 10
        # ~ dmimgadapt.radscale = "linear"
        # ~ dmimgadapt.counts = 1
        # ~ dmimgadapt(clobber=True)

        go_rm(f"{self.outroot}_marx.fits")
        go_rm(f"{self.outroot}_reprojmarx.fits")
        if 'SAVE_ALL' not in os.environ:
            from shutil import rmtree
            rmtree(f"{self.outroot}_marxdir")

        marx_crate = read_file(outfile)

        if flip:
            # Get the data and flop it back
            verb1("\tflip(flip(I_0/(I_n ⊙ P)) ⊙ P)")
            vals = marx_crate.get_image().values
            flip_vals = np.flip(vals, axis=[0, 1])
            marx_crate.get_image().values = flip_vals
            marx_crate.write(f"{self.outroot}_marxflop.img", clobber=True)
            marx_crate = read_file(f"{self.outroot}_marxflop.img")
            go_rm(f"{self.outroot}_marxflip.img")

        return marx_crate


def go_rm(delme):
    'Wrapper around remove'

    if 'SAVE_ALL' in os.environ:
        return

    if os.path.exists(delme):
        os.unlink(delme)


def my_clobber_check(outroot, clobber):
    '''Check different output file names to clobber'''
    from ciao_contrib._tools.fileio import outfile_clobber_checks

    for outfile in ["_counts.img", ]:
        outfile_clobber_checks(clobber, f"{outroot}{outfile}")


def convolve_observations(observations, infile, outroot, nproc, flip=False):
    'Loop over observations and convolve, now in parallel'
    from ciao_contrib._tools.taskrunner import TaskRunner
    taskrunner = TaskRunner()

    for obs in observations:
        # ~ obs.convolve_using_marx(infile, flip)
        taskrunner.add_task(obs.outroot, "", obs.convolve_using_marx,
                            infile, flip)

    taskrunner.run_tasks(processes=nproc)

    if flip:
        sum_obs(observations, "_marxflop.img", outroot)
        outimg = read_file(f"{outroot}_marxflop.img")
    else:
        sum_obs(observations, "_marx.img", outroot)
        outimg = read_file(f"{outroot}_marx.img")

    return outimg


def rl_deconvolution(observations, numiter, outroot, nproc):
    'Perform Richardson Lucy deconvolution'

    # The iterative algorithm is just:

    #                  /     I_0         \
    #  I_{n+1} = I_n * | --------- ⊙ P^  |
    #                  \  I_n ⊙ P        /
    #
    #  where P^ is the flip of the PSF, P
    #

    # Setup for 1st iteration,

    counts_file = f"{outroot}_counts.img"
    img0_crate = read_file(counts_file)
    img0_vals = img0_crate.get_image().values * 1.0  # make a copy

    outfile = counts_file  # 1st iteration
    img_n_plus_1 = img0_vals    # 1st iteration

    for xxp1 in range(1, numiter+1):

        verb1(f"Iteration {xxp1:04d}")

        # Run marx using input image.  This is the denominator of
        # the fraction (I_n \circledast P)
        verb1("\tI_n ⊙ P")

        # Setup for next iteration
        img_n_vals = img_n_plus_1

        den_n = convolve_observations(observations, outfile, outroot, nproc)

        den_n_vals = den_n.get_image().values*1.0

        # We need to renorm since number "psf" is not normalized
        renorm = np.sum(img_n_vals*1.0)/np.sum(den_n_vals)
        den_n_vals *= renorm

        # Compute the division, set inf's to 0
        verb1("\tI_0/(I_n ⊙ P)")
        fraction = np.nan_to_num(img0_vals/den_n_vals, 0, posinf=0)

        den_n.get_image().values = fraction
        den_n.write(f"{outroot}_frac.img", clobber=True)

        # We cannot flip the marx simulation, but we can use
        # the identity
        #     a^ ⊙ b^ = (a ⊙ b)^
        # so
        #    (a^ ⊙ b^)^ = a ⊙ b
        # letting using P^ = b, then
        #     (a^ ⊙ P)^ = (a ⊙ P^)
        # the RHS is the quantity inside the ()'s and we can
        # can compute the flips needed to compute the LHS.

        # Now run marx with the flipped data
        verb1("\tflip(I_0/(I_n ⊙ P)) ⊙ P")
        img_flip_n = convolve_observations(observations,
                                           f"{outroot}_frac.img",
                                           outroot, nproc, flip=True)

        img_flop_n_vals = img_flip_n.get_image().values

        # Renorm by the sum of the fraction
        renorm = np.sum(fraction*1.0)/np.sum(img_flop_n_vals)
        img_flop_n_vals = img_flop_n_vals * renorm

        # Finally multiply by the n-the iteration
        verb1("\tI_n * flip(flip(I_0/(I_n ⊙ P)) ⊙ P)")
        img_n_plus_1 = img_n_vals * img_flop_n_vals

        # Write those values out and setup for the next loop
        outfile = f"{outroot}_{xxp1:04d}_out.img"
        img_flip_n.get_image().values = img_n_plus_1
        img_flip_n.write(outfile, clobber=True)

        # TBR: automatically stop iterations if some
        # condition is met?

    for suffix in ["flip.img", "marx.img", "frac.img",
                   "marxflop.img", "img.lis", "img.op"]:
        go_rm(f"{outroot}_{suffix}")

    for obs in observations:
        go_rm(obs.marx.marx_par)

    return outfile


def make_full_grid(observations, binsize):
    'Compute the grid that covers all the observations'
    xlo = min([obs.phys_limits['xlo'] for obs in observations])
    ylo = min([obs.phys_limits['ylo'] for obs in observations])
    xhi = max([obs.phys_limits['xhi'] for obs in observations])
    yhi = max([obs.phys_limits['yhi'] for obs in observations])

    full_grid = f"[bin x={xlo}:{xhi}:{binsize},y={ylo}:{yhi}:{binsize}]"
    verb2(f"Full grid is {full_grid}")

    for obs in observations:
        xcenter = obs.phys_limits['xcen']
        ycenter = obs.phys_limits['ycen']
        new_xlen = max([xcenter-xlo, xhi-xcenter])

        new_ylen = max([ycenter-ylo, yhi-ycenter])

        new_xgrid = f"x={xcenter-new_xlen}:{xcenter+new_xlen}:{binsize}"
        new_ygrid = f"y={ycenter-new_ylen}:{ycenter+new_ylen}:{binsize}"

        obs.bin_grid = f"[bin {new_xgrid},{new_ygrid}]"
        verb2(obs.keys['OBS_ID']+" "+obs.bin_grid)

    return full_grid


def sum_obs(observations, suffix, outroot):
    'Combine the observations'

    infiles = [obs.outroot+suffix+obs.full_grid
               for obs in observations]
    with open(f"{outroot}_img.lis", "w") as fp:
        fp.write("\n".join(infiles))
        fp.write("\n")

    numerator = []
    denominator = []

    for ii, obs in enumerate(observations):
        numerator.append(f"(img{ii+1}*{obs.counts})")
        denominator.append(f"{obs.counts}")

    numerator = "+".join(numerator)
    denominator = "+".join(denominator)
    operation = "imgout=("+numerator+")/((float)("+denominator+"))"

    with open(f"{outroot}_img.op", "w") as fp:
        fp.write(operation.replace("+", "+\\\n"))
        fp.write("\n")

    dmimgcalc = make_tool("dmimgcalc")
    dmimgcalc.infile = f"@-{outroot}_img.lis"
    dmimgcalc.outfile = f"{outroot}{suffix}"
    dmimgcalc.operation = f"@-{outroot}_img.op"
    dmimgcalc(clobber=True)

    for obs in observations:
        infile = obs.outroot+suffix
        go_rm(infile)


def check_obs(observations):
    'Some simple consistency checks'

    okay = True
    mesg = ""
    obi_list = []
    for obs in observations:
        if obs.keys['RA_NOM'] != observations[0].keys['RA_NOM']:
            okay = False
            mesg += f"ERROR: RA_NOM keyword is different in OBS_ID {obs.keys['OBS_ID']}\n"
        if obs.keys['DEC_NOM'] != observations[0].keys['DEC_NOM']:
            okay = False
            mesg += f"ERROR: DEC_NOM keyword is different in OBS_ID {obs.keys['OBS_ID']}\n"
        if obs.keys['OBS_ID'] in obi_list:
            # TODO: Support multi-obi obsids by adding obi_num
            okay = False
            mesg += f"ERROR: Multiple copies of OBS_ID {obs.keys['OBS_ID']} are not allowed\n"

        obi_list.append(obs.keys['OBS_ID'])

    if not okay:
        raise RuntimeError(mesg)


def set_nproc(pars):
    'Set number of processors'

    if "no" == pars["parallel"]:
        pars["nproc"] = 1
    else:
        if pars["nproc"] != "INDEF":
            pars["nproc"] = int(pars["nproc"])
        else:
            pars["nproc"] = 999   # Hack, else history gets stuck with a pset


def create_observations(pars):
    'Create the observations objects'

    def check_asolfiles():
        gziped = [x for x in asol_files if x.endswith(".gz")]
        if len(gziped) != 0:
            gziped = "\n".join(gziped)
            raise IOError(f"ERROR: These aspect solution files must be gunzip'ed:\n{gziped}")

    def make_obs(stuff):
        'Wrapper to help create object'
        obs = Observation(*stuff)
        return obs

    import stk
    event_files = stk.build(pars["infile"])
    asol_files = stk.build(pars["asolfile"])
    fov_files = stk.build(pars["fovfile"])

    # TODO: Lookup asol files using from ciao_contrib.ancillaryfiles import find_ancillary_files
    if len(event_files) != len(asol_files):
        raise IOError("ERROR: Mismatch in number of event files and aspect solution files")
    if len(event_files) != len(fov_files):
        raise IOError("ERROR: Mismatch in number of event files and FOV files")

    check_asolfiles()

    stuff = []
    for evt, asp, fov in zip(event_files, asol_files, fov_files):
        stuff.append((evt, fov, asp, pars["binsize"], pars["outroot"]))

    myobs = parallel_map(make_obs, stuff, numcores=int(pars["nproc"]))

    return myobs


def setup_marx(myobs, pars, full_grid):
    'Setup marx objects'

    def make_marx(obsr):
        'Wrapper to run in parallel'
        obsr.make_counts_image(full_grid)
        obsr.make_marx_dot_par(pars["energy"], pars["flux"],
                               pars["random_seed"], pars["marx_root"])
        # I need to return the updated object back
        return obsr

    new_obs = parallel_map(make_marx, myobs, numcores=int(pars["nproc"]))
    return new_obs


@lw.handle_ciao_errors(__toolname__, __revision__)
def main():
    """Main routine"""

    from ciao_contrib.param_soaker import get_params
    pars = get_params(__toolname__, "rw", sys.argv,
                      verbose={"set": lw.set_verbosity, "cmd": verb1})

    my_clobber_check(pars["outroot"], pars["clobber"])
    set_nproc(pars)

    myobs = create_observations(pars)
    check_obs(myobs)
    full_grid = make_full_grid(myobs, pars["binsize"])

    myobs = setup_marx(myobs, pars, full_grid)

    sum_obs(myobs, "_counts.img", pars["outroot"])

    outfile = rl_deconvolution(myobs, int(pars["numiter"]),
                               pars["outroot"], pars["nproc"])

    from ciao_contrib.runtool import add_tool_history
    add_tool_history(outfile, __toolname__, pars,
                     toolversion=__revision__)

    verb1("")
    verb1(f"Orignal Image: {pars['outroot']}_counts.img")
    verb1(f"Deconvolved Image: {outfile}")


if __name__ == '__main__':
    main()

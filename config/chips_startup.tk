# This is called chips_startup.tk for historical reasons (the CIAO
# installation uses this name and it is easier to keep than change
# for the time being) even though ChIPS is no-longer used by dax.

global env

# Need to make sure CIAO's paths are first
set env(PATH) $env(ASCDS_INSTALL)/bin:$env(PATH)

## Dax output directory setup
if { [info exists env(DAX_OUTDIR)] == 0 } {
    set env(DAX_OUTDIR) [exec -ignorestderr pget dax outdir]
}
file mkdir $env(DAX_OUTDIR)


proc ChangeDaxOutdir {} {
    global env
    set dir [tk_chooseDirectory -initialdir $env(DAX_OUTDIR) -title "DAX output directory" ]
    if { $dir ne "" } {
        set env(DAX_OUTDIR) $dir
        file mkdir $env(DAX_OUTDIR)
    }
}


# Add a progress bar for long running processes

proc start_dax_progress { tnam } {

  if { [exec -ignorestderr pget dax progress_bar] == "no"} {
    return
  }

  set winnam "dax_"
  append winnam $tnam

  toplevel .${winnam}
  wm title .${winnam} "CIAO (DAX)"

  ttk::frame .${winnam}.dp
  grid .${winnam}.dp -row 0 -column 0
  ttk::label .${winnam}.dp.toolname -text $tnam
  grid .${winnam}.dp.toolname -padx 5 -pady 5 -row 0 -column 0

  ttk::progressbar .${winnam}.dp.toolname_pb -mode indeterminate -max 15
  grid .${winnam}.dp.toolname_pb -padx 5 -pady 5 -row 0 -column 1
  .${winnam}.dp.toolname_pb start
}

proc stop_dax_progress {tnam} {

  if { [exec -ignorestderr pget dax progress_bar] == "no"} {
    return
  }

  set winnam "dax_"
  append winnam $tnam

  if { [winfo exists .${winnam}] } {
    .${winnam}.dp.toolname_pb stop
    destroy .${winnam}
  }
}



# --------- Setup for interactive tg coordinates

set tgcoords_arm 0
set tgcoords_tg_r 1
set tgcoords_tg_d 2
set tgcoords_energy 3
set tgcoords_wavelength 4
set tgcoords_order 1
set tgcoords_frame 0
set tgcoords_id 1

proc run_tgcoords { frame id } {
    # Process the magic grating region w/ special callbacks added.

    global ds9
    global tgcoords_order
    global current

    if { $frame == 0 } {
        set frm $current(frame)
    } else {
        set frm [puts $frame]
    }

    set coords [$frm get marker $id line point physical]
    set x0 [lindex $coords 0]
    set y0 [lindex $coords 1]
    set x1 [lindex $coords 2]
    set y1 [lindex $coords 3]

    launch_tgcoords_ui $frame $id

    # I need to put this into the background so that the script,
    # ds9_itgcoords, can make XPA calls.  Otherwise, the Tk event loop is
    # hung at this command and the XPA command in ds9_itgcoords times out.
    exec {ds9_itgcoords} $ds9(title) $tgcoords_order $x0 $y0 $x1 $y1 $frame $id &
}


proc launch_tgcoords_ui {frame id } {
    # The TK widget to display the results

    global tgcoords_frame
    global tgcoords_id

    if {[winfo exists .tgcoords ]} {
        return
    }

    set tgcoords_frame $frame
    set tgcoords_id $id

    toplevel .tgcoords
    ttk::frame .tgcoords.frm
    pack .tgcoords.frm

    ttk::label .tgcoords.frm.arm_label -text {Grating Arm}
    ttk::label .tgcoords.frm.ord_label -text {Order}
    ttk::label .tgcoords.frm.tgr_label -text {TG_R [deg]}
    ttk::label .tgcoords.frm.tgd_label -text {TG_D [deg]}
    ttk::label .tgcoords.frm.eng_label -text {Energy [keV]}
    ttk::label .tgcoords.frm.wav_label -text {Wavelength [A]}
    ttk::entry .tgcoords.frm.arm_value -textvariable tgcoords_arm
    ttk::entry .tgcoords.frm.ord_value -textvariable tgcoords_order
    ttk::entry .tgcoords.frm.tgr_value -textvariable tgcoords_tg_r
    ttk::entry .tgcoords.frm.tgd_value -textvariable tgcoords_tg_d
    ttk::entry .tgcoords.frm.eng_value -textvariable tgcoords_energy
    ttk::entry .tgcoords.frm.wav_value -textvariable tgcoords_wavelength

    grid .tgcoords.frm.arm_label -row 1 -column 1 -padx 5
    grid .tgcoords.frm.ord_label -row 2 -column 1 -padx 5
    grid .tgcoords.frm.tgr_label -row 3 -column 1 -padx 5
    grid .tgcoords.frm.tgd_label -row 4 -column 1 -padx 5
    grid .tgcoords.frm.eng_label -row 5 -column 1 -padx 5
    grid .tgcoords.frm.wav_label -row 6 -column 1 -padx 5

    grid .tgcoords.frm.arm_value -row 1 -column 2 -padx 5
    grid .tgcoords.frm.ord_value -row 2 -column 2 -padx 5
    grid .tgcoords.frm.tgr_value -row 3 -column 2 -padx 5
    grid .tgcoords.frm.tgd_value -row 4 -column 2 -padx 5
    grid .tgcoords.frm.eng_value -row 5 -column 2 -padx 5
    grid .tgcoords.frm.wav_value -row 6 -column 2 -padx 5

    bind .tgcoords.frm.ord_value <Return> {run_tgcoords $tgcoords_frame $tgcoords_id}

}


proc display_tgcoords { tgr tgd energy arm frame id} {
    # Update the display with the newly computed values

    global tgcoords_arm
    global tgcoords_tg_r
    global tgcoords_tg_d
    global tgcoords_energy
    global tgcoords_wavelength

    set tgcoords_arm $arm
    set tgcoords_tg_r $tgr
    set tgcoords_tg_d $tgd
    set tgcoords_energy $energy

    set tgcoords_wavelength [expr 12.39842 / $energy]


    if {[winfo exists .tgcoords ] == 0} {
        launch_tgcoords_ui $frame $id
    }
}


# --------------------------------------------------------------------
# --------------------------------------------------------------------
# --------------------------------------------------------------------
# These routines add "elastic ellipse" capabilities


proc get_ciao_filename {tag_token id} {

    # Create CIAO compatible filename from the
    # on disk file, region, binning+filtering, blocking, cropping

    global current

    set frm [set current(frame)]
    set filename [$frm get fits file name full base]

    # Get column/axis names
    set cols [$frm get bin cols]
    if {$cols eq ""} {
        set cols {x y}
    }
    set xcol [lindex $cols 0]
    set ycol [lindex $cols 1]

    # Get CIAO region string, requires only 1 region
    # We filter on tag to get individual shape
    set tid_ $tag_token$id
    set tag_ "tag = $tid_"
    set ciaoreg [$frm marker list ciao physical no {} $tag_ ]

    if {[llength $ciaoreg] == 0} {
        error "Cannot find region with correct tag" "No Region" 405
    } elseif {[llength $ciaoreg] > 1} {
        error "More than one region has same tag" "Too Many Selected" 406
    }
    set ciao [string trim $ciaoreg "\n"]

    # Get image crop
    set crpfilt [$frm get crop physical]
    set crp [regsub -all " " $crpfilt ","];   # xlo, ylo, xhi, yhi
    set crop_ rectangle($crp)

    # We need to AND shape and the crop rectangle
    set shape_ ($xcol,$ycol)=$ciao*$crop_

    # If event list, get any filter. Will be blank for images
    set binfilt [$frm get bin filter]

    # Construct filter expression
    if {$binfilt eq ""} {
        set posfilt "\[$shape_\]"
    } else {
        set posfilt "\[$shape_,$binfilt\]"
    }

    # Get blocking factor
    set blck [$frm get block factor]
    set xblk [lindex $blck 0]
    set yblk [lindex $blck 1]

    # For event list we need to bin into an image
    set cols [$frm get bin cols]
    if {$cols eq ""} {
        set bincmd "\[bin #1=$xblk,#2=$yblk\]"
    } else {
        # For events, multiply bin and block factors. This is not
        # technically correct due to partial pixels but best we can do.
        set binsize [$frm get bin factor]
        set xbin [expr [lindex $binsize 0] * $xblk]
        set ybin [expr [lindex $binsize 1] * $yblk]
        set bincmd "\[bin $xcol=$xbin,$ycol=$ybin\]"
    }

    # Construct full file name
    return $filename$posfilt$bincmd

}

# ----------------------------------------------
# CIAO plotting routines

proc ciao_plotter {tag_token id data label} {
    # "Simple" XY plotter

    # based on markeranalysishist.tcl
    global current

    set frm $current(frame)

    set vvarname [string tolower ${tag_token}${id}${frm}]
    upvar #0 $vvarname vvar
    global $vvarname

    set vvar(frame) $frm
    set vvar(id) $id
    set xdata ${vvarname}xx
    set ydata ${vvarname}yy
    global $xdata $ydata

    upvar 1 $label mylabel
    upvar 1 $data mydata

    if {[info command $xdata] == {}} {
        blt::vector create $xdata $ydata
    }

    # BLT set vectors
    $xdata set $mydata(xx)
    $ydata set $mydata(yy)

    if {![PlotPing $vvarname]} {
        PlotDialog $vvarname [string totitle [$frm get marker $id type]] true
        PlotAddGraph $vvarname line
        PlotTitle $vvarname $mylabel(title) $mylabel(xlabel) $mylabel(ylabel)

        set vvar(graph,ds,xdata) $xdata
        set vvar(graph,ds,ydata) $ydata
        set vvar(graph,ds,line,smooth) step
        set vvar(graph,ds,line,fill) 0
        PlotExternal $vvarname xy
    }

    PlotStats $vvarname
    PlotList $vvarname
}

proc add_ciao_callback {frm id tag_token cb end_} {
    # Add callback to marker
    $frm marker $id callback $end_ move $cb $tag_token
    $frm marker $id callback $end_ edit $cb $tag_token
    $frm marker $id callback $end_ rotate $cb $tag_token
    $frm marker $id tag $tag_token$id

}

proc delete_ciao_callback {frm id tag_token cb end_} {
    # Delete callback from marker
    $frm marker $id delete tag $tag_token$id
    $frm marker $id delete $end_ callback move $cb
    $frm marker $id delete $end_ callback edit $cb
    $frm marker $id delete $end_ callback rotate $cb
}

proc enable_ciao_callback {tag_token cb end_} {
    # Add CIAO histogram to all selected ciao-compatible shapes
    global current
    set frm [set current(frame)]
    set slct [$frm get marker select]
    foreach id $slct {
        set shp [$frm get marker $id type]
        switch $shp {
            circle -
            ellipse -
            box -
            polygon -
            annulus -
            point {
                add_ciao_callback $frm $id $tag_token $cb $end_
            }
        }
    }
}

proc disable_ciao_callback {tag_token cb end_} {
    # Disable CIAO histogram callback
    global current
    set frm [set current(frame)]
    set slct [$frm get marker select]
    foreach id $slct {
        set shp [$frm get marker $id type]
        switch $shp {
            circle -
            ellipse -
            box -
            polygon -
            annulus -
            point {
                delete_ciao_callback $frm $id $tag_token $cb $end_
            }
        }
    }
}


# ---------------------------
#
# These routines are used to add a callback to ellipse regions
# that will set the Text of the ellipse to the sum of the pixel
# values (aka counts).
#

proc get_counts_CB { tag_token id } {
    # The callback that will compute the counts in the region
    # and set the regions text to it.

    global current
    set frm [set current(frame)]

    #Construct CIAO syntax for filename w/ filters, bin, block, crops
    set infile [get_ciao_filename $tag_token $id]

    # Run dmstat and return out_sum value
    # TODO: fix race condition PFILES
    exec dmstat $infile cen- sig- med- verb=0
    set sumval [exec pget dmstat out_sum]

    # Have to use escaped brackets since sumval is an integer
    $frm marker $id text \{$sumval\}

}

proc make_count_shape {} {
    # Create a new ellipse with the callbacks already enabled.

    global current
    global env

    if {[info exists env(ASCDS_INSTALL)]} {
        set frm [set current(frame)]
        set pos [$frm get cursor physical]

        # Create creates in WCS coordinates, so move to center in physical
        set mkr [$frm marker create ellipse $pos 20 20 0 ]
        $frm marker $mkr select
        enable_ciao_callback CountShape get_counts_CB {}
        $frm marker $mkr move to physical $pos
    } else {
        tk_messageBox -message "You must have CIAO setup first" -type ok
    }

}

proc enable_count_ellipse {} {
    # This will add the count callback to all selected ellipses
    enable_ciao_callback CountShape get_counts_CB {}
}

proc disable_count_ellipse {} {
    # This will remove the count callback from all selected ellipses
    disable_ciao_callback CountShape get_counts_CB {}
}

# --------------------
# These routines will create an elastic ellipse that will snap to
# the size, angle, and centoid of the data.

proc get_ellipse_CB {tag_token id} {
    # The elastic ellipse callback

    global current
    set frm [set current(frame)]

    #Construct CIAO syntax for filename w/ filters, bin, block, crops
    set infile [get_ciao_filename $tag_token $id]

    # Run the imgmoment CIAO tool to get centroid, angle, and sizes
    exec imgmoment $infile
    set vals [regsub -all "\n" [exec pget imgmoment x_mu y_mu xsig ysig phi] " "]

    # If the pixel values have low stddev, then probably background
    # and the region will artificially expand ad nauseam. This is a simple
    # check to see if pixel values are all the same, if so then small sigma
    # and do not scale by the sqrt(2) needed to scale imgmoment "sig" values
    exec dmstat $infile centroid- sig+ med- verb=0
    set sigma [exec pget dmstat out_sigma]
    set factor [expr {$sigma < 1 ? 1.0 : 1.4142135623730951}]

    set xx [lindex $vals 0]
    set yy [lindex $vals 1]
    set r1 [expr [lindex $vals 2] * $factor]
    set r2 [expr [lindex $vals 3] * $factor]
    set aa [lindex $vals 4]

    $frm marker $id ellipse radius $r1 $r2 physical
    $frm marker $id angle $aa physical
    $frm marker $id move to physical $xx $yy
}

proc add_adaptive_callback {frm id} {
    # Since the CB "moves", "edits", and "rotates" the shape,
    # we need to specify that this should only be run at the END
    # action.  Otherwise the callback goes into an infinite loop
    # and ds9 crashes.

    set tag_token AdaptiveShape
    $frm marker $id callback end move get_ellipse_CB $tag_token
    $frm marker $id callback end edit get_ellipse_CB $tag_token
    $frm marker $id callback end rotate get_ellipse_CB $tag_token
    $frm marker $id tag $tag_token$id
    $frm marker $id highlite
    $frm marker $id color violet

}

proc make_adaptive_ellipse {} {
    # Creates an ellipse in the center of the display with the
    # elastic ellipse callbacks enabled

    global current
    global env

    if {[info exists env(ASCDS_INSTALL)]} {
        set frm [set current(frame)]
        set pos [$frm get cursor physical]

        # Create creates in WCS coordinates, so move to center in physical
        set mkr [$frm marker create ellipse $pos 20 20 0 ]
        add_adaptive_callback $frm $mkr
        $frm marker $mkr move to physical $pos
    } else {
        tk_messageBox -message "You must have CIAO setup first" -type ok
    }

}

proc enable_adaptive_ellipse {} {
    # Add adaptive resizing to all selected ellipse shapes

    global current

    set frm [set current(frame)]
    set slct [$frm get marker select]

    foreach id $slct {
        set shp [$frm get marker $id type]
        if {$shp ne "ellipse"} {
            continue
        }
        add_adaptive_callback $frm $id
    }
}

proc disable_adaptive_ellipse {} {
    # Disable the elastic ellipse callbacks

    global current

    set frm [set current(frame)]
    set tag_token AdaptiveShape

    set slct [$frm get marker select]

    foreach id $slct {
        set shp [$frm get marker $id type]
        if {$shp ne "ellipse"} {
            continue
        }

        $frm marker $id delete tag $tag_token$id
        $frm marker $id delete callback end move get_ellipse_CB
        $frm marker $id delete callback end edit get_ellipse_CB
        $frm marker $id delete callback end rotate get_ellipse_CB
        $frm marker $id unhighlite
        $frm marker $id color green
    }
}

# --------------------

proc enable_lightcurve_shape {} {
    #
    global current
    set frm $current(frame)

    set binfilt [$frm get fits header keyword extname]
    switch $binfilt {
        "EVENTS" -
        "STDEVT" {
            enable_ciao_callback LightcurveShape ciao_lc_plotter_cb {}
        }
        default {
            tk_messageBox -message "Lightcurve only works with EVENT files." -type ok
        }
    }
}

proc disable_lightcurve_shape {} {
    disable_ciao_callback LightcurveShape ciao_lc_plotter_cb {}
}

proc run_dmextract_ltc {tag_token id} {
    # Run dmextract in light curve mode

    set binsize [exec pget dax lc_binsize]

    set infile [get_ciao_filename $tag_token $id]
    set infile [regsub {\[bin .*\]} $infile ""]
    set infile "${infile}\[bin time=::${binsize}\]"

    set vals [exec dmextract ${infile} \
                          out=- op=ltc1 bkg="" exp="" bkgexp=""  | \
                          dmlist -\[cols\ dt,count_rate\] data,clean | \
                          grep -v COUNT_RATE ]

    set x_ {}
    set y_ {}
    foreach {i j} [regsub -all "\n" $vals " " ] {
        lappend x_ [expr $i / 1000.0]
        lappend y_ $j
    }

    set retval {}
    lappend retval $x_
    lappend retval $y_
    return $retval
}

proc ciao_lc_plotter_cb {tag_token id} {
    # Run CIAO command to get xy values to plot
    set xy [run_dmextract_ltc $tag_token $id]

    set data(xx) [lindex $xy 0]
    set data(yy) [lindex $xy 1]
    set label(title) {Lightcurve}
    set label(xlabel) {Delta Time [ksec]}
    set label(ylabel) {Count Rate [c/sec]}

    ciao_plotter $tag_token $id data label
}

# -----------------------------------------------

proc enable_spectrum_shape {} {
    #
    global current
    set frm $current(frame)

    set binfilt [$frm get fits header keyword extname]
    switch $binfilt {
        "EVENTS" -
        "STDEVT" {
            enable_ciao_callback SpectrumShape ciao_pi_plotter_cb {}
        }
        default {
            tk_messageBox -message "Spectrum only works with EVENT files." -type ok
        }
    }
}

proc disable_spectrum_shape {} {
    disable_ciao_callback SpectrumShape ciao_pi_plotter_cb {}
}

proc run_dmextract_pi {tag_token id} {
    # Run dmextract in spectral mode

    set grp [exec pget dax grptype]
    set grpval [exec pget dax grpval]
    set binspec [exec pget dax grpbin]

    set infile [get_ciao_filename $tag_token $id]
    set infile [regsub {\[bin .*\]} $infile ""]
    set infile "${infile}\[bin pi=1:1024:1\]"

    set vals [exec dmextract ${infile} \
                        out=- op=pha1 bkg="" exp="" bkgexp=""  | \
                   dmgroup - - \
                        grouptype=$grp grouptypeval=$grpval binspec=$binspec xcol=channel ycol=counts | \
                   dmlist "-\[grouping=1\]\[cols channel,grp_data\]" data,clean | \
                          grep -v CHANNEL ]

    set x_ {}
    set y_ {}
    foreach {i j} [regsub -all "\n" $vals " " ] {
        lappend x_ $i
        lappend y_ $j
    }

    set retval {}
    lappend retval $x_
    lappend retval $y_
    return $retval
}

proc ciao_pi_plotter_cb {tag_token id} {
    # Run CIAO command to get xy values to plot
    set xy [run_dmextract_pi $tag_token $id]

    set data(xx) [lindex $xy 0]
    set data(yy) [lindex $xy 1]
    set label(title) {Spectrum}
    set label(xlabel) {PI}
    set label(ylabel) {Counts}

    ciao_plotter $tag_token $id data label
}

# -------------------------------------
# Add keyboard bindings to enable/disable

#~ bind . <F3> enable_lightcurve_shape
#~ bind . <F4> disable_lightcurve_shape
#~ bind . <Shift-F3> enable_spectrum_shape
#~ bind . <Shift-F4> disable_spectrum_shape


#~ bind . <F5> make_count_shape
#~ bind . <F7> enable_count_ellipse
#~ bind . <F8> disable_count_ellipse

#~ bind . <F9> make_adaptive_ellipse
#~ bind . <F11> enable_adaptive_ellipse
#~ bind . <F12> disable_adaptive_ellipse





